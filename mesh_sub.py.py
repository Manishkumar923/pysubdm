#=======================================================================#
# These codes are generated by Dr. Manish Kumar and Prof. Enrico Salvati
# which can be used as a computational model to simulate the presence of
# the secondary small phases present in the polycrystalline materials, 
# e.g., inclusions, intermetallic, and many more. The provided codes can
# be used to generate a mathematical domain to resemble actual microstructures,
# which can be used in various micromechanical models. For instance, in crystal
# plasticity, phase transformations, failure mechanisms through Phase-Filed or
# Cohesive Zone Method, etc. The provided code is for the two-dimensional model
# but can be easily extended to the three-dimensional problem.  

# Contact email: Manish Kumar <manish.kumar@uniud.it>, Enrico Salvati 
# <enrico.salvati@uniud.it>, Group website https://simed.uniud.it/

# This code generates 2D rectangular domain resembling a polycrystalline material
# that contains the primary and secondary small subdomains using the Python API of
# the Gmsh library. 

# The secondary small domains are randomly positioned and oriented in the primary subdomains.

# The secondary small subdomains are non-intersecting between themself. These also have the 
# minimum distance from crack and boundaries of primary domain and primary subdomains.

# The mesh can be used as a computational model to simulate the effects of the secondary
# small phases in the grains.

# The generated mesh can be converted in .xml using the command dolfin-convert inputmesh.msh
# outputmesh.xml

# All the features are extracted as physical entities by converting the mesh in this manner,
# which can be directly imported into FEniCS to apply different material properties.

# More details can be found in the provided document. 

#=====================================================================#

# Copyright (C) <2023>  <Manish Kumar>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License or 
# (at your option) any later version.

# This program is distributed in the hope that it will be useful, 
# but WITHOUT ANY WARRANTY, without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
# GNU General Public License for more details.

#You should have received a copy of the GNU General Public License 
# along with these programs. If not, see <http://www.gnu.org/licenses/>.

#=====================================================================#

# Required libraries
import gmsh
import sys
import random
import math
import numpy as np
from shapely import geometry

# Seed to produce a random number
random.seed(10)

# Initialize gmsh
gmsh.initialize()

# Provide the name of the gmsh model
gmsh.model.add('Cantilever')

# Parameters
lc = 5e-5                                    # Mesh size control parameter
length = 0.01                                # Length of the primary domain
height = 0.004                               # Height of the primary domain
load_point = 0.0005                          # location of the load point
num_sec_sub = 40                             # Number of secondary small subdomains
length_of_sec_sub = 0.0002                   # Length of the secondary small subdomain
height_of_sec_sub = 0.00002                  # Height of the secondary small subdomain
radius_of_sec_sub = 0.5*length_of_sec_sub    # This parameter is used to make the
                                             # seconadry subdomains not self 
                                             # intersecting. It is equal to the half
                                             # of the biggest dimension of the secondary small subdomain

# Coordinates to define the primary subdomains
G1 = 0.003
G2 = 0.0055
G3 = 0.008
G4 = 0.0022
G5 = 0.0085
G6 = 0.005
G7 = 0.0032
G8 = 0.002
G9_x = 0.0025
G9_y = 0.0017
G10_x = 0.006
G10_y = 0.0025
G11_x = 0.0075
G11_y = 0.0019

# Number of nodes for secondary small subdomains
fine_l = 12
fine_h = 4

# Define points
P1  = gmsh.model.geo.addPoint(0, 0, 0, lc,1)
P2  = gmsh.model.geo.addPoint(length, 0, 0, lc,2)
P3  = gmsh.model.geo.addPoint(length, height, 0, lc,3)
P4  = gmsh.model.geo.addPoint(load_point, height, 0, lc,7)
P5  = gmsh.model.geo.addPoint(0, height, 0, lc,8)
P6  = gmsh.model.geo.addPoint(G1, 0, 0, lc,9)
P7  = gmsh.model.geo.addPoint(G2, 0, 0, lc,10)
P8  = gmsh.model.geo.addPoint(G3, 0, 0, lc,11)
P9  = gmsh.model.geo.addPoint(length, G4, 0, lc,12)
P10  = gmsh.model.geo.addPoint(G5, height, 0, lc,13)
P11  = gmsh.model.geo.addPoint(G6, height, 0, lc,14)
P12  = gmsh.model.geo.addPoint(G7, height, 0, lc,15)
P13  = gmsh.model.geo.addPoint(0, G8, 0, lc,16)
P14  = gmsh.model.geo.addPoint(G9_x, G9_y, 0, lc,17)
P15  = gmsh.model.geo.addPoint(G10_x, G10_y, 0, lc,18)
P16  = gmsh.model.geo.addPoint(G11_x, G11_y, 0, lc,19)


# Define lines
L1   = gmsh.model.geo.addLine(P1, P6,1)
L2   = gmsh.model.geo.addLine(P6, P7,2)
L3   = gmsh.model.geo.addLine(P7, P8,3)
L4   = gmsh.model.geo.addLine(P8, P2,4)
L5   = gmsh.model.geo.addLine(P2, P9,5)
L6   = gmsh.model.geo.addLine(P9, P3,6)
L7   = gmsh.model.geo.addLine(P3, P10,7)
L8   = gmsh.model.geo.addLine(P10, P11,8)
L9   = gmsh.model.geo.addLine(P11, P12,9)
L10  = gmsh.model.geo.addLine(P12, P4,10)
L11  = gmsh.model.geo.addLine(P4, P5,11)
L12  = gmsh.model.geo.addLine(P5, P13,12)
L13  = gmsh.model.geo.addLine(P13, P1,13)

L14  = gmsh.model.geo.addLine(P13, P14,14)
L15  = gmsh.model.geo.addLine(P6, P14,15)
L16  = gmsh.model.geo.addLine(P12, P14,16)
L17  = gmsh.model.geo.addLine(P14, P15,17)
L18  = gmsh.model.geo.addLine(P7, P15,18)
L19  = gmsh.model.geo.addLine(P11, P15,19)
L20  = gmsh.model.geo.addLine(P15, P16,20)
L21  = gmsh.model.geo.addLine(P8, P16,21)
L22  = gmsh.model.geo.addLine(P16, P10,22)
L23  = gmsh.model.geo.addLine(P16, P9,23)


# Defien loops
C1 = gmsh.model.geo.addCurveLoop([1, 15, -14, 13],1)
C2 = gmsh.model.geo.addCurveLoop([2, 18, -17, -15],2)
C3 = gmsh.model.geo.addCurveLoop([3, 21, -20, -18],3)
C4 = gmsh.model.geo.addCurveLoop([4, 5, -23, -21],4)
C5 = gmsh.model.geo.addCurveLoop([14, -16, 10, 11, 12],5)
C6 = gmsh.model.geo.addCurveLoop([17, -19, 9, 16],6)
C7 = gmsh.model.geo.addCurveLoop([20, 22, 8, 19],7)
C8 = gmsh.model.geo.addCurveLoop([23, 6, 7, -22],8)


# Synchronize the defined geometry
gmsh.model.geo.synchronize()

# Define physical groups (Lines)
Phyl1 = gmsh.model.addPhysicalGroup(1, [L1],1)
Phyl2 = gmsh.model.addPhysicalGroup(1, [L2],2)
Phyl3 = gmsh.model.addPhysicalGroup(1, [L3],3)
Phyl4 = gmsh.model.addPhysicalGroup(1, [L4],4)
Phyl5 = gmsh.model.addPhysicalGroup(1, [L5],5)
Phyl6 = gmsh.model.addPhysicalGroup(1, [L6],6)
Phyl7 = gmsh.model.addPhysicalGroup(1, [L7],7)
Phyl8 = gmsh.model.addPhysicalGroup(1, [L8],8)
Phyl9 = gmsh.model.addPhysicalGroup(1, [L9],9)
Phyl10 = gmsh.model.addPhysicalGroup(1, [L10],10)
Phyl11 = gmsh.model.addPhysicalGroup(1, [L11],11)
Phyl12 = gmsh.model.addPhysicalGroup(1, [L12],12)
Phyl13 = gmsh.model.addPhysicalGroup(1, [L13],13)
Phyl14 = gmsh.model.addPhysicalGroup(1, [L14],14)
Phyl15 = gmsh.model.addPhysicalGroup(1, [L15],15)
Phyl16 = gmsh.model.addPhysicalGroup(1, [L16],16)
Phyl17 = gmsh.model.addPhysicalGroup(1, [L17],17)
Phyl18 = gmsh.model.addPhysicalGroup(1, [L18],18)
Phyl19 = gmsh.model.addPhysicalGroup(1, [L19],19)
Phyl20 = gmsh.model.addPhysicalGroup(1, [L20],20)
Phyl21 = gmsh.model.addPhysicalGroup(1, [L21],21)
Phyl22 = gmsh.model.addPhysicalGroup(1, [L22],22)
Phyl23 = gmsh.model.addPhysicalGroup(1, [L23],23)


# Polygons created by primary subdomains
sec_sub_list = []
sec_sub_B_list = []
sec_sub_B_list.append([(0, 0), (G1, 0), (G9_x, G9_y), (0, G8)])
sec_sub_B_list.append([(G1, 0), (G2, 0), (G10_x, G10_y), (G9_x, G9_y)])
sec_sub_B_list.append([(G2, 0), (G3, 0), (G11_x, G11_y), (G10_x, G10_y)])
sec_sub_B_list.append([(G3, 0), (length, 0), (length, G4), (G11_x, G11_y)])
sec_sub_B_list.append([(0, G8), (G9_x, G9_y), (G7, height), (0, height)])
sec_sub_B_list.append([(G9_x, G9_y), (G10_x, G10_y), (G6, height), (G7, height)])
sec_sub_B_list.append([(G10_x, G10_y), (G11_x, G11_y), (G5, height), (G6, height)])
sec_sub_B_list.append([(G11_x, G11_y), (length, G4), (length, height), (G5, height)])




# function to check if the secondary small subdomain lies in the primary subdomain
def check_sec_sub(coords,factor,point_check):
    lines = [[coords[i-1], coords[i]] for i in range(len(coords))]

    xs = [i[0] for i in coords]
    ys = [i[1] for i in coords]
    x_center = 0.5 * min(xs) + 0.5 * max(xs)
    y_center = 0.5 * min(ys) + 0.5 * max(ys)

    min_corner = geometry.Point(min(xs), min(ys))
    max_corner = geometry.Point(max(xs), max(ys))
    center = geometry.Point(x_center, y_center)
    shrink_distance = center.distance(min_corner)*factor

    my_polygon = geometry.Polygon(coords)
    my_polygon_shrunken = my_polygon.buffer(-shrink_distance)

    x, y = my_polygon_shrunken.exterior.xy
    point = geometry.Point(point_check[0])

    my_1 = geometry.polygon.Polygon([(x[0], y[0]), (x[1], y[1]), (x[2], y[2]), (x[3], y[3])])

    if (my_1.contains(point)):
        pt_contain = 1
    else:
        pt_contain = 0
    return pt_contain

# function to maintain the minimum distance from previous center points
def euclidean_py(x, y):
    if len(x) != len(y):
        raise ValueError("vectors must be same length")
    sum = 0
    for i in range(len(x)):
        sum += (x[i]-y[i])**2
    return math.sqrt(sum)
    
# Initialize the counters for the while loop
count = 1
k = 1
i = 1

# Empty array to record in which primary subdomain, secondary small subdomain lies
sec_sub_loc = np.zeros(num_sec_sub)
while i <= num_sec_sub:
    # Maximum number of iterations 
    maxTries = 1000
    
    while len(sec_sub_list) < i:

        maxTries -= 1
        
        # Flags
        wrong_center = 0
        sec_sub_center = 0
        
        if maxTries < 1:
            print("Maximum Distribution tries exceded. Error! Restart the Script!")
            break
 
        # Generation of random center point
        center_point = [random.random()*length, random.random()*height,0]
        
        # Condition to make sure the secondary small subdomain does not cut the boundary of the primary domain
        if center_point[0] <= 0.95*length and center_point[0] >= 0.05*length and center_point[1] <= 0.95*height and center_point[1] >= 0.05*height:
            
            # Condition to make sure secondary small subdomains are not self-intersecting
            for pos in sec_sub_list:
                if euclidean_py(pos, center_point) < 4*radius_of_sec_sub:
                    wrong_center = wrong_center + 1
            
            # Condition to make sure the secondary small subdomain does not cut the boundary of the primary subdomain
            for j in range(len(sec_sub_B_list)):
                coords = sec_sub_B_list[j]
                factor = 0.05              # Shrunk parameter
                point_check = [(center_point[0], center_point[1])]
                if check_sec_sub(coords,factor,point_check):
                    sec_sub_loc[i-1] =j+1                      
                    sec_sub_center = sec_sub_center + 1
                    
            # Define secondary small subdomain for the accepted center point
            if wrong_center == 0 and sec_sub_center == 1:
                sec_sub_list.append(center_point)
                angle = 2*math.pi*random.random()    # Generate a random angle to rotate the secondary subdomain
            
                # Define points
                gmsh.model.geo.addPoint(center_point[0] - 0.5*length_of_sec_sub, center_point[1] - 0.5*height_of_sec_sub, 0, lc,22 + k)
                gmsh.model.geo.addPoint(center_point[0] + 0.5*length_of_sec_sub, center_point[1] - 0.5*height_of_sec_sub, 0, lc,23 + k)
                gmsh.model.geo.addPoint(center_point[0] + 0.5*length_of_sec_sub, center_point[1] + 0.5*height_of_sec_sub, 0, lc,24 + k)
                gmsh.model.geo.addPoint(center_point[0] - 0.5*length_of_sec_sub, center_point[1] + 0.5*height_of_sec_sub, 0, lc,25 + k)
                
                # Define lines
                gmsh.model.geo.addLine(22 + k, 23 + k,31+k)
                gmsh.model.geo.addLine(23 + k, 24 + k,32+k)
                gmsh.model.geo.addLine(24 + k, 25 + k,33+k)
                gmsh.model.geo.addLine(25 + k, 22 + k,34+k)
                
                # Define loop
                gmsh.model.geo.addCurveLoop([31 + k, 32 + k, 33 + k, 34 + k],10 + count)
                
                # Define planer surface (secondary small subdomain)
                gmsh.model.geo.addPlaneSurface([10 + count],20 + count)
                
                # Rotate the secondary small subdomain by a random angle
                gmsh.model.geo.rotate([(2, 20 + count)], center_point[0], center_point[1], 0, 0, 0, 1, angle)
                
                # Synchronize the defined geometry
                gmsh.model.geo.synchronize()
                
                # Define physical groups (Lines)
                gmsh.model.addPhysicalGroup(1, [31 + k],31 + k)
                gmsh.model.addPhysicalGroup(1, [32 + k],32 + k)
                gmsh.model.addPhysicalGroup(1, [33 + k],33 + k)
                gmsh.model.addPhysicalGroup(1, [34 + k],34 + k)
                
                # Define physical groups (secondary small subdomain)
                gmsh.model.addPhysicalGroup(2, [20+count],110+count)
                
                # Update counters
                i = i +1 
                count = count + 1
                k = k + 4
                
                break

# Check if the secondary small subdomain lies in 1st primary subdomain
sec_sub_1 = []
sec_sub_1.append(1)
for i in range (num_sec_sub):
    if sec_sub_loc[i] == 1:
        sec_sub_1.append(10 + i+1)

# Check if the secondary small subdomain lies in 2nd primary subdomain
sec_sub_2 = []
sec_sub_2.append(2)
for i in range (num_sec_sub):
    if sec_sub_loc[i] == 2:
        sec_sub_2.append(10 + i+1)

# Check if the secondary small subdomain lies in 3rd primary subdomain
sec_sub_3 = []
sec_sub_3.append(3)
for i in range (num_sec_sub):
    if sec_sub_loc[i] == 3:
        sec_sub_3.append(10 + i+1)

# Check if the secondary small subdomain lies in 4th primary subdomain
sec_sub_4 = []
sec_sub_4.append(4)
for i in range (num_sec_sub):
    if sec_sub_loc[i] == 4:
        sec_sub_4.append(10 + i+1)
        
# Check if the secondary small subdomain lies in 5th primary subdomain
sec_sub_5 = []
sec_sub_5.append(5)
for i in range (num_sec_sub):
    if sec_sub_loc[i] == 5:
        sec_sub_5.append(10 + i+1)

# Check if the secondary small subdomain lies in 6th primary subdomain
sec_sub_6 = []
sec_sub_6.append(6)
for i in range (num_sec_sub):
    if sec_sub_loc[i] == 6:
        sec_sub_6.append(10 + i+1)

# Check if the secondary small subdomain lies in 7th primary subdomain
sec_sub_7 = []
sec_sub_7.append(7)
for i in range (num_sec_sub):
    if sec_sub_loc[i] == 7:
        sec_sub_7.append(10 + i+1)

# Check if the secondary small subdomain lies in 8th primary subdomain
sec_sub_8 = []
sec_sub_8.append(8)
for i in range (num_sec_sub):
    if sec_sub_loc[i] == 8:
        sec_sub_8.append(10 + i+1)
 
# Define surface (Primary subdomain)
PS11 = gmsh.model.geo.addPlaneSurface(sec_sub_1,11)
PS12 = gmsh.model.geo.addPlaneSurface(sec_sub_2,12)
PS13 = gmsh.model.geo.addPlaneSurface(sec_sub_3,13)
PS14 = gmsh.model.geo.addPlaneSurface(sec_sub_4,14)
PS15 = gmsh.model.geo.addPlaneSurface(sec_sub_5,15)
PS16 = gmsh.model.geo.addPlaneSurface(sec_sub_6,16)
PS17 = gmsh.model.geo.addPlaneSurface(sec_sub_7,17)
PS18 = gmsh.model.geo.addPlaneSurface(sec_sub_8,18)

# Synchronize the defined geometry
gmsh.model.geo.synchronize()

# Define physical groups (primary subdomain)
Phys1 = gmsh.model.addPhysicalGroup(2, [PS11],101)
Phys2 = gmsh.model.addPhysicalGroup(2, [PS12],102)
Phys3 = gmsh.model.addPhysicalGroup(2, [PS13],103)
Phys4 = gmsh.model.addPhysicalGroup(2, [PS14],104)
Phys5 = gmsh.model.addPhysicalGroup(2, [PS15],105)
Phys6 = gmsh.model.addPhysicalGroup(2, [PS16],106)
Phys7 = gmsh.model.addPhysicalGroup(2, [PS17],107)
Phys8 = gmsh.model.addPhysicalGroup(2, [PS18],108)


# Define the number of elements in secondary small subdomains
list3 = [i for i in range(32,4*num_sec_sub+31,2)]
list4 = [i for i in range(33,4*num_sec_sub+32,2)]

for i in list3: gmsh.model.mesh.setTransfiniteCurve(i, fine_l)
for i in list4: gmsh.model.mesh.setTransfiniteCurve(i, fine_h)  


list1 = [i for i in range(21,21+num_sec_sub)]
for i in list1: gmsh.model.mesh.setTransfiniteSurface(i)

# Setting format and element types for meshing
gmsh.option.setNumber("Mesh.Algorithm", 5)

# Setting format to save the mesh file
gmsh.option.setNumber('Mesh.MshFileVersion', 2.2)

# Generate 2D Mesh
gmsh.model.mesh.generate(2)

# Save mesh file
gmsh.write("inputmesh.msh")

# To stop popup opening of Gmsh GUI
if '-nopopup' not in sys.argv:
    gmsh.fltk.run()

# Finalize gmsh
gmsh.finalize()
