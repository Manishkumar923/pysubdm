#=======================================================================#
# These codes are generated by Dr. Manish Kumar and Prof. Enrico Salvati 
# which can be used as a computational model to simulate the effects of 
# the secondary small phases present in the grains.

# Contact email: Manish Kumar <manish.kumar@uniud.it>, Enrico Salvati 
# <enrico.salvati@uniud.it>, Group website https://simed.uniud.it/

# This code generates to import the generated mesh and assigns the different
# material properties to the domain and subdomains, and simulate for the
# linear elastic isotropic material considering small-scale deformations
# using the Python API of the FEniCS library.

# More details can be found in the provided document. 

#=====================================================================#

# Copyright (C) <2023>  <Manish Kumar>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License or 
# (at your option) any later version.

# This program is distributed in the hope that it will be useful, 
# but WITHOUT ANY WARRANTY, without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
# GNU General Public License for more details.

#You should have received a copy of the GNU General Public License 
# along with these programs. If not, see <http://www.gnu.org/licenses/>.

#=====================================================================#

# Required libraries
from fenics import *              

# Define Material Properties
nu = 0.25                                # Poisson ratio
length_cant = 0.01                       # length of cantilever
height_cant = 0.004                       # Height of cantilever
loading_point = 0.0005                   # Loading point
  
# Import Mesh Data
# Mesh data
mesh = Mesh("outputmesh.xml")

# Subdomain data        
subdomains = MeshFunction("double", mesh, "outputmesh_physical_region.xml")  

# Dimension of a geometry     
ndim = mesh.topology().dim()        


# Create function space for displacement
V_u = VectorFunctionSpace(mesh, 'CG', 1)


# Define a function to assign different material properties
# to subdomains using cpp interface
cpp_code = """

#include <pybind11/pybind11.h>
#include <pybind11/eigen.h>
namespace py = pybind11;

#include <dolfin/function/Expression.h>
#include <dolfin/mesh/MeshFunction.h>


class K : public dolfin::Expression
{
public:

  // Create an expression with 3 components
  K() : dolfin::Expression() {}

  // Function for evaluating the expression of each cell
  void eval(Eigen::Ref<Eigen::VectorXd> values, Eigen::Ref<const Eigen::VectorXd> x, const ufc::cell& cell) const override
  { 
    // Condition to select subdomains for specific material properties 
    if ((*subdomains)[cell.index] > 110)   // condition for secondary small subdomain     
        values[0] = 200E2;
    else if ((*subdomains)[cell.index] < 105)   // condition for primary subdomain for material 1     
        values[0] = 100E3;
    else
        values[0] = 200E3;         // condition for primary subdomain for material 2
  }

  // The data stored in mesh functions
  std::shared_ptr<dolfin::MeshFunction<double>> subdomains;

};

PYBIND11_MODULE(SIGNATURE, m)
{
  py::class_<K, std::shared_ptr<K>, dolfin::Expression>
    (m, "K")
    .def(py::init<>())
    .def_readwrite("subdomains", &K::subdomains);
}

"""

# Call the function to assign different material properties to subdomains
E_1 = CompiledExpression(compile_cpp_code(cpp_code).K(),
                       subdomains= subdomains, degree=0)

mu    = E_1/(2.0*(1.0 + nu))                        #lame's constant 
lmbda = (E_1 * nu)/((1.0 - 2.0*nu)*(1.0 + nu))      #lame's constant


# Define the function, test, and trial fields
u = Function(V_u)            # Function
du = TrialFunction(V_u)      # Trial Function
v = TestFunction(V_u)        # Test function

# Identify the boundaries to apply boundary conditions
tol = 1E-7

# Right side edge to fix
def boundary_fix(x, on_boundary):
    return x[0] >= length_cant-tol

        
bc_1 = DirichletBC(V_u, Constant((0.0 ,0.0)), boundary_fix, method='pointwise')               # define boundary condition

# Point on the left side to apply a point load
def boundary_D_t(x, on_boundary):
    return x[0] <= loading_point + tol and x[0] >= loading_point - tol and x[1] >= height_cant - tol

bc_2 = DirichletBC(V_u.sub(1),-0.001, boundary_D_t, method='pointwise') 

# define the function for strain tensor as a function of the displacement
def epsilon(u):
    return sym(grad(u))

# Define the function for stress tensor as a function of the displacement
def sigma(u):
    return 2.0*mu*(epsilon(u)) + lmbda*tr(epsilon(u))*Identity(ndim)

#  Define and set the problem
T = Constant((0, 0))
a = inner(sigma(du), epsilon(v))*dx
L = dot(T, v)*ds

# solve the problem
solve(a == L, u, [bc_1, bc_2])